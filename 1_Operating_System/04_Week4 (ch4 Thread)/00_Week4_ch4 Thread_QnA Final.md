# Ch3/4. Process & Thread 

<br>
<br>

## 심상민
### 1. 클라이언트 서버에서 사용가능한 두 가지 다른 통신 전략은 무엇인가요? 둘의 장단점은 무엇인가요?

- 소켓
	- 분산된 프로세스 간에 널리 사용되고 효율적임
	- 바이트 스트림만을 통신하도록 하기에 낮은 수준의 통신임
	- 데이터를 구조화하여 해석하는 것은 클라이언트와 서버의 책임 
- 원격 프로시저 호출
	- 프로시저 혹은 함수를 호출하는 높은 수준의 통신 기법임
	- 전달되는 메시지는 구조화되어 있고, 데이터의 패킷 수준을 넘어섬.
	- Android IPC로도 활용하고 있음.  
	
### 2. 다중 스레드 프로그래밍의 장점으로 응답성, 자원 공유, 경제성, 규모 적응성 말하고 있다. 각각의 의미가 무엇인가?

- 응답성(responsiveness)
	- 프로그램의 수행이 계속되는 것을 허용함으로써, 사용자에 대한 응답성을 증가시킴. 시간이 오래 걸리는 연산이 별도의 비동기적 스레드에서 실행된다면 응용은 여전히 사용자에게 응답할 수 있음.
- 자원 공유(resource sharing)
	- 프로그래머가 명시적으로 처리하지 않아도 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유함.
- 경제성(economy)
	- 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비함. 문맥 교환은 프로세스 사이보다 스레드 사이에서 더 빠름.
- 규모 적응성(scalability)
	- 다중 처리기 구조에서 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있음.

<br>
------
<br>

## 박예리

### 1. MultiProcessing과 Multithreading의 차이 (+ Multicore는?)
Multiprocessing은 하나의 Task마다 {Code, Data, Heap, Stack} 레이아웃의 프로세스를 할당하여 한 프로세스가 한 작업만을 수행하는 것이다.
이에 반해, Multithreading은 한 프로세스 내에서 여러개의 Task를 수행할 수 있도록 해당 프로세스의 {Code, Data, Heap}은 공유하면서 Stack 만을 개별로 가지면서 여러 작업을 동시에 수행하는 것이다.
Multicore는 하드웨어적인 접근으로 코어가 여러개 있는 것. 

CPU Scheduler가 한 코어에 한 프로세스를 할당한다.
Thread는 Process의 흐름.

    Q. Multicore에서 Multithreading이 더 중요해진 이유?
    TBD... 

    #### 1-1. CPU의 병렬처리와 GPU의 병렬처리는 어떻게 다른가?
    CPU의 병렬처리는 여러개의 코어에서 동시적으로 여러개의 일을 수행하는 Task 관점의 병렬처리이고,
    GPU는 한 Task의 데이터를 수백개의 코어에 분할하여 반복적인 작업을 통해 빠르게 병렬 연산하는 병렬 처리를 의미한다. (Data의 병렬성)
    따라서 GPU는 병렬 연산은 가능하다 Multiprocessing은 아니다. 

<br>
------
<br>

## 이재인

### 1. 동기식 스레딩은 명시적 스레딩과 암묵적 스레딩 둘 다 적용 될 수 있다. 각 방식의  공통점및 차이점은?
- 공통점
	- Parent thread가 child thread를 생성하고 모두 종료할 때까지 대기한다
	- 비동기식에 비해 스레드 끼리 상당한 양의 데이터 공유를 한다 
- 명시적 스레딩
	- 개발자가 직접 스레드를 구축한다. 
- 암묵적 스레딩
	- 컴파일러, 런타임 라이브러리가 스레드를 생성 및 관리한다.
	- Fork-join 모델에서, fork 단계 시 스레드가 직접 구축되지 않고 병렬 작업을 할당한다.
	- 라이브러리는 생성되는 스레스 수를 관리하며 스레드에 작업을 배정한다.

<br>
------
<br>

## 김민정

### 1. Interprocess Communication(IPC) 의 두가지 모델과 그 장단점은?
Message Passing과 Share Memory.

Message Passing은 송신 프로세스가 정보를 받는 수신 프로세스에게 커널을 통해 정보를 전달하며, 수신 프로세스도 커널에 접근해 정보를 수신한다. 컨텍스트 스위치가 발생하기 때문에 속도가 느리지만, 커널이 대신 전달해주기 때문에 동기화 문제가 없다. 커널이 기본적인 기능을 제공하므로 공유 메모리 방식에 비해선 구현이 쉽다.

Shared Memory는 특정 메모리 공간을 두 프로세스가 함께 사용하며 정보를 주고 받는다. 커널을 거치지 않아 속도가 빠르지만 동기화 문제가 있다. (메모리 동시 접근) 이를 해결하기 위해 구현을 따로 해줘야 한다.

![IPC](https://blog.kakaocdn.net/dn/bDS16L/btq6cUgBhUP/ctoU6yixvYtxP6TDYgU4zK/img.png)

### 2. 멀티 쓰레드의 장단점?
장점: 
1. 응답성이 좋다. - 프로그램의 일부분이 중단되거나 하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다. (ex. 하나의 쓰레드는 이미지 파일 로드 / 다른 하나는 사용자와 상호작용)
2. 자원 공유가 효율적이다. - 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리공간, 시스템 자원 소모가 줄어듬. 프로세스의 context switching과 달리 스레드 간의 context switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.

단점:
1. 동기화에 주의해야 한다. - 공유 자원에 동시에 접근하는 경우, 프로세스와 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 다른 스레드에서 사용중인 변수나 자료구조에 접근할 수 있음.
2. 성능이 저하될 수 있다. - 너무 많은 스레드를 생성하는 경우, 불필요한 부분까지 동기화를 하는 경우 과도한 lock으로 인해 병목 현상을 발생시켜 성능이 저하될 가능성이 높다.


<br>
------
<br>

## 김현준

### 1. thread에 포함되는 레지스터가 뜻하는 것은??
레지스터를 가지는 것이 아닌 레지스터가 가지고 있는 값을 의미한다.
각 스레드가 레지스터를 가지는 이유는 현재 명령어가 어디까지 수행되었는 지, 수행할 때 쓰던 데이터는 무엇인지 기록이 필요하기 때문이다.

cpu의 레지스터(기억장치)를 의미하지 않는다.

https://superuser.com/questions/1501489/how-can-every-thread-have-its-own-register


<br>
------
<br>


## 이재하

### 1. 멀티스레드의 단점

- 동기화 문제
	- 스레드들끼리 공유 자원을 사용하기 때문에 이 자원에 대한 동기화 문제가 발생하는데, 이를 맞춰주어야 함
	  - ![thread_](https://velog.velcdn.com/images/chjh121/post/d8c055d1-6d7f-468a-ac18-a2206e717478/img.png)
  - 설계, 디버깅 시 어렵다
	
### 2. 멀티 프로세스의 단점

- context switching 과정에서 오버헤드 발생 (프로세스간 공유 데이터가 없기 때문에 context switching 발생 시 캐시에 있는 데이터를 모두 리셋해야 함)
  - context switching? : 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다. 
- 프로세스끼리의 통신은 IPC라는 방식을 이용하여 통신을 함. 이 과정에서 오버헤드


<br>
------
<br>


## 김장윤

### 1. 동기식 스레딩은 명시적 스레딩과 암묵적 스레딩 둘 다 적용 될 수 있다. 각 방식의  공통점및 차이점은?
- 공통점
	- Parent thread가 child thread를 생성하고 모두 종료할 때까지 대기한다
	- 비동기식에 비해 스레드 끼리 상당한 양의 데이터 공유를 한다 
- 명시적 스레딩
	- 개발자가 직접 스레드를 구축한다. 
- 암묵적 스레딩
	- 컴파일러, 런타임 라이브러리가 스레드를 생성 및 관리한다.
	- Fork-join 모델에서, fork 단계 시 스레드가 직접 구축되지 않고 병렬 작업을 할당한다.
	- 라이브러리는 생성되는 스레스 수를 관리하며 스레드에 작업을 배정한다.